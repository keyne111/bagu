Java语言有什么特点？

1：简单易学

2：面向对象（封装，继承，多态）

3：跨平台性（Java虚拟机实现平台无关性）

4：可靠性（Java语言具有异常处理机制和自动内存管理机制）

5：内置多线程（像C++没有内置多线程，依靠的是操作系统的多线程功能实现，而Java内置了多线程）

6：安全性（Java语言的设计思想具有多重安全防护机制，如访问权限修饰符，限制程序直接访问操作系统资源）

7：高效性（Java有just in time等编译器的优化，Java的执行效率不错）

8：支持网络编程并且很方便

9：编译与解释共存



JVM&& JDK&&JRE

JVM是Java虚拟机，是运行字节码文件的虚拟机，它有针对不同操作系统的实现，目的是使用相同的字节码文件，在不同的操作系统下可以得到相同的结果，字节码文件和不同操作系统的JVM是实现Java语言 ”一次编译，随处可以执行“ 的关键

JRE是Java运行时环境和必要的类库，JDK包含了JRE和Javac,javadoc等工具

一个.java文件会被javac编译器编译成.class文件，再被Java虚拟机执行则变成了我们看到的样子



什么是字节码文件？采用字节码文件的好处是什么？

Java虚拟机可以执行的文件是字节码文件，即.class文件，采用字节码文件的好处：

1：解决了传统解释型语言执行效率低的特点，保留了解释型语言可移植性的特点，运行时相对高效

2：一次编译，随处可以执行



为什么说Java语言编译与解释共存？

首先编译型语言是一次性把代码翻译成机器码再执行，执行速度快，开发效率低，像C,C++就是编译型语言

而解释型语言是边解释边执行，开发效率高，执行速度慢，像python，JavaScript就是解释型语言

而Java语言既具有编译型语言的特点，又具有解释型语言的特点，Java语言是先编译后执行，把Java文件编译成.class文件，再被Java解释器或JIT编译器解释。



Java与C++的区别？

首先，它们都是面向对象，都具有封装，继承，多态

但是，1：Java没有指针操作访问程序，程序内存更加安全

​		2：Java的类是单继承的，C++支持多重继承，Java的接口可以多继承

​		3：C++有方法重载和操作符重载，Java只有方法重载，因为操作符重载跟Java要设计简单的思路不同

​		4：Java具有自动内存管理回收机制（GC），程序员无需手动释放无用内存。



注释有哪几种？

单行，多行，文档注释



标识符和关键字区别？

标识符就是用来给起名字的，给类，方法，变量等， 命名规则是数字，字母，下划线或美元符号，不能以数字开头，也不能以关键字命名

关键字是有特殊含义的标识符，比如private，class等，并且关键字都是小写开头

true，false，null不是关键字，而是字面值，但是也不能作为标识符使用



continue，break，return的区别？

continue：跳出当前循环，进入下一次循环

break：跳出整个循环

return：两种用法，带返回值终止程序，不带返回值终止程序



Java中的基本数据类型

byte，

short，

int，

long (默认值 oL),使用long型时，如果不加L会作为int类型去编译

float（默认值 0f），数值后必须加f或F，否则编译失败

double（默认值 0d）

char

boolean （false）

它们的包装类型除了int和char是Integer和Character,其它都是首字母大写



基本类型和包装类型的区别？

1：用途：除了常量和局部变量之外，在其它的地方如方法参数，对象属性等很少使用基本类型，而且包装类型可以作为泛型，基本类型不行

2：存储方式：基本类型的局部变量存储在Java虚拟机栈中的局部变量表中，（未被static修饰的）成员变量存放在Java虚拟机堆中，被static修饰的成员变量也存放在堆中，不过它属于类，不属于对象，而包装类型属于对象类型，几乎所有对象类型都存放在堆中

3：存储大小：相对于包装类型，基本类型占据的大小往往非常小

4：默认值：成员变量的包装类型不赋值有默认值是null，而基本类型不赋值有默认值且不为null

5：比较方式：基本类型的值用= =比较，而包装类型用= =比较的是内存地址，要比较值大小要用equals方法



包装类型的缓存机制了解吗？

包装类型大部分都有使用缓存机制提高性能。

如Byte,Short,Integer,Long创建了[-128,127]的数值，Character创建了[0,127]的数值，Boolean返回的true或false，而float和double类型则没有使用缓存机制

只要创建了范围内的数值，使用的都是缓存中的对象，不过要注意的是只要数值相等才返回的同一个对象，不然是不同的对象

Integer i=40;

Integer i=Integer.valueOf(40);



自动装箱与自动拆箱了解吗？原理是什么？

装箱指的是把基本类型变成包装类型，Integer i=1; 它也等价于Integer i=Integer.valueOf(1);

拆箱指的是把包装类型变成基本类型，int j=i; 它也等价于int j=i.intValue();

装箱利用了valueOf()方法

拆箱利用了xxxValue()方法

然后要注意不能频繁拆装箱，很影响系统性能的。



为什么浮点数运算会有精度丢失的风险？怎么解决精度丢失的问题？

这跟计算机存储浮点数的机制有关，计算机是二进制的，如果遇到无限循环的小数的话，由于宽度有限，只能进行截断操作，这就造成了精度丢失的风险。

解决这个问题可以用BigDecimal，它不会造成精度丢失，在一些业务场景，尤其涉及到钱的，经常使用这个BigDecimal



超过long整形的数据如何表示？

可以用BigInteger,它内部使用int[]数组表示任意大小的整形数据，不过相较于正常整数运算来说，它的运算效率较低



成员变量和局部变量的区别？

语法形式：从语法形式上看，成员变量是属于类的，局部变量是代码块或方法中定义的变量或方法中的参数，并且，成员变量可以被public，private，static等修饰，局部变量不能被访问权限修饰符和static所修饰，同时，它们都可以被final所修饰

存储方式：局部变量存放在Java虚拟机栈中的局部变量表中，（未被static修饰的）成员变量存放在Java虚拟机堆中，被static修饰的成员变量也放在堆中，不过它是属于类的，不是属于对象

生存时间：成员变量是属于类的，它随着对象的创建而自动生成，局部变量是随着方法的调用而自动生成，随着方法的调用结束而自动消亡

默认值：成员变量未赋初值时有默认值，如包装类型默认值是null，基本类型则是各自类型默认值。而局部变量未赋初值时无默认值



为什么成员变量有默认值？

假如没有默认值，变量存储的是内存地址对应的一段任意值，到时变量运行会出现意外；

默认值的设置方法有两种，手动和自动，不手动设置的话，成员变量可以在运行时通过反射等方法赋值，局部变量不行

另外在被编译器编译时，局部变量不赋值很好判断，而成员变量不好判断，因为它可能是运行时再赋值，如果直接报错，会给用户不好的体验，所以设置了自动赋值



静态变量有什么作用？

静态变量是被static修饰的变量，可以通过类名.变量使用，无论一个类创建多少个对象，静态变量只会被分配一次内存，这样可以节省内存。然后静态变量通常被final修饰成常量



字符常量和字符串常量的区别？

形式：字符常量是由单引号引起的一个字符，字符串常量是由双引号引起的0个或若干个字符

含义：字符常量表示一个整形值，可以参与表达式运算。字符串常量表示一串内存地址

占内存大小：字符常量只占两个字节，字符串常量占若干个字节



什么是方法的返回值，方法有哪几种类型？

方法体中的代码执行后的结果，如果有返回值的话，它用于接收结果，用于其它操作，

按照参数和返回值分：

无参无返，无参有返，有参无返，有参有返



静态方法为什么不能调用非静态成员？

静态方法是属于类的，在类加载的时候去分配内存，此时就可以通过类名.方法去调用。而非静态成员变量属于实例，在对象实例创建之后才能调用。也就是说，静态方法存在时非静态成员还不存在，调用非静态成员属于非法操作，会报错



静态方法和实例方法（普通方法）有什么不同？

1：调用方式：静态方法可以通过类名.方法去调用，也可以通过对象.方法去调用，而实例方法只能通过对象.方法去调用，也就是说，静态方法调用时无需创建对象

2：访问类成员的限制：静态方法中只能访问静态成员变量和静态成员方法，无法访问非静态成员变量和非静态成员变量方法，而实例方法中就没有这个限制。它两者都可以访问，这个是因为静态方法是属于类，在类加载的时候就存在了，而非静态成员属于对象，在对象实例创建后才能访问，就是静态方法在的时候非静态成员还没存在。



方法重载和方法重写的区别？

重载：同个类中（或者父类和子类之间）方法名相同，根据输入数据的不同，做出不同的处理

重写：子类继承父类的相同方法时，输入数据相同，但要做出不同于父类的响应

重载要求方法名相同，参数列表不同包括参数类型，参数顺序，参数个数的不同，访问权限修饰符和返回值可以不同

重载的话，要求方法名和参数列表相同，访问权限修饰符大于等于父类的访问权限修饰符，返回值和异常小于等于父类的返回值和异常。要注意父类的构造方法和被private,static,final修饰的方法不能被重写



什么是可变长参数？

函数的参数列表中传入不定数量的参数，定义的话用类型...,如int...,然后可变长参数都是放在参数列表的末尾的，只有单它一个参数的时候才放在最前面。

遇到方法重载时，会优先匹配固定参数的函数而不是有可变长参数的函数，最后是可变长参数被编译后实际上是变成了数组的



面向对象和面向过程的区别？

主要是解决问题的过程不同

面向对象是先抽取出对象，利用对象执行方法解决问题

面向过程是把解决问题的过程抽成一个个方法，利用一个个的方法执行解决问题

面向对象开发的程序一般更容易维护，扩展，复用



创建一个对象用什么运算符？对象引用和对象实例有什么区别？

创建一个对象用new运算符，对象实例是存放在堆内存中，而对象引用是指向对象实例的，它存放在栈内存中，

一个对象引用可以指向0或1个对象

一个对象实例可以被n个对象引用指向



对象的相等和引用的相等的区别？

对象的相等比较的是内存中存放的内容是否相等，用equals方法

引用的相等比较的是指向的内存地址是否相等，用==



如果一个类没有声明构造方法，程序还能执行下去吗？

可以执行下去，首先构造方法的作用是完成对象的初始化工作，如果没有无参的构造方法的话，程序会自动生成一个无参构造方法，然后如果自己有重载有参的构造方法的话，最好把无参的构造方法也写下去，这样可以避免在创建的时候少踩坑



构造方法有哪些特点？是否可被重写？

方法名和类名相同，无返回值，不能用void声明构造方法，在new对象的时候自动执行，无需手动执行

构造方法不能被重写，都是可以被重载



面向对象三大特征？

封装，继承，多态

封装的话隐藏类的内部状态信息，外部不能直接访问类的内部信息，但是可以提供给外界访问的方法（getter和setter），就像我们使用空调，我们不知道空调的内部零件，但是我们可以通过遥控器使用空调，一个类中要是有属性不想提供给外界使用，那就不要提供让外界访问的方法，然后如果一个类完全没有提供让外界访问的方法，那这个类没有意义



继承：子类继承父类的全部属性和方法，包含被private修饰的，但是子类无法访问它们，子类可以有自己的属性和方法，也可以重写父类的方法。

多态有三个条件：1：要有继承，2：子类重写父类的方法，3：父类引用指向子类实例

封装和继承让代码更容易复用，多态让代码更容易移植，也更健壮



接口和抽象类有什么共同点和区别？

共同点：

都不能直接被实例化，接口需要被实现，抽象类需要被继承之后才能创建具体的实例对象

都可以包含抽象方法，抽象方法没有方法体，要由子类或实现类去具体实现

区别：

接口主要用于对类的行为进行规范，实现了某个接口就具有了具体的行为，而抽象类主要用于代码复用，强调所属关系

Java中的类是单继承的，一个类只能继承一个类（包含抽象类），一个接口可以实现多个接口，也可以继承多个其它接口

接口中的成员变量必须是public static final，不能被修改且必须赋值，而抽象类中的成员变量可以是其它类型，并且可以由子类重新定义和赋值



深拷贝和引用拷贝了解吗？引用拷贝呢？

深拷贝：完全复制整个对象，包括对象的内部对象

浅拷贝：会在堆上重新复制一个对象，并且原对象和拷贝对象指向同一个内部对象

引用拷贝：两个不同的引用指向同一个对象



Object类的常见方法有哪些？

getClass()

hasCode()

equals()

clone()

toString()

notify()

notifyAll()

wait()

wait()

wait()

finalize() 实例被垃圾回收器回收时的操作



==和equals的区别？

对于基本类型来说，==比较的是值是否相等

对于引用类型来说，==比较的是内存地址是否相等

而对于equals方法，要分两种情况，一种是没重写过的，它相对于==，比较是内存地址是否相等，有重写过的，像String类，比较的是两个对象的属性是否相等



hashCode()有什么作用？为什么要有hashCode？

获取哈希码，哈希码的作用是确定对象在哈希表中的索引位置，哈希表存储的是键值对，根据这个key可以快速找到所需要的对象，hashCode有以下特性，如果两个对象的hashCode不等，这两个对象不是同一个对象，如果两个对象的hashCode相等，两个对象不一定是同个对象，只有两个对象的hashCode相等并且equals方法也相等，才能说明它们是同个对象，所以hashCode还可以减少equals的次数，提高比较两个对象是否相等的效率。



为什么重写equals()方法还要重写hashCode()方法？

如果两个对象的hashCode相等，并不能说明两个对象的equals方法相等，因为可能是由于哈希碰撞，而两个对象的equals方法相等，可以说明两个对象的hashCode相等，如果只重写equals方法，可能会造成equals方法相等，但是hashCode又不相等。



String,StringBuilder,StringBuffer的区别？

可变性: String类型是不可变的，而StringBuilder和StringBuffer继承了AbstractStringBuilder，有修改字符串的方法，所以它们可变

线程安全：String中的对象不可变，相对于常量，线程安全。StringBuilder没有对方法执行同步锁，线程不安全，StringBuffer有对方法或调用的方法加同步锁，线程安全

性能：StringBuilder比StringBuffer的性能好上10%-15%，但是要冒线程不安全的风险

总结：操作少量数据用String,单线程下操作大量数据用StringBuilder,多线程下操作大量数据用StringBuffer



String类为什么是不可变的？

1:保存字符串的数组被final修饰且为私有的，没有提供让外界修改字符串的方法

2：String类被final修饰，其子类不能继承，避免了子类破坏String的不可变



字符串拼接用”+“还是StringBuilder？

用StringBuilder好，因为+操作实际上也是调用StringBuilder的append方法再通过toString转成字符串的，并且在JDK9之前，使用+操作容易创建多个StringBuilder对象，JDK9之后，有一个动态方法可以去减少创建StringBuilder对象



String类型的equals方法和Object类型的equals方法有何区别？

Object类型的equals比较的是两个对象的内存地址是否相等，等价于==，而String类型的equals方法有经过重写，比较的是两个字符串的值是否相等



字符串的常量池了解吗？

JVM专门开辟出来的节约内存，提高性能的一片区域，主要是避免字符串的重复创建



String s1=new String("abc");这句话创建了几个对象？

可能会创建一个或两个对象

首先会在字符串常量池中找是否有这个对象的引用，如果没有找到，则会在堆上创建两个对象，其中一个作为字符串常量的引用，如果有找到，则在堆上创建一个对象



String s1="abc";

会先在字符串常量池中找是否有这个对象的引用，如果没有找到，则会在堆上创建一个对象，如果有找到，则会直接返回这个引用



String的intern方法有什么作用？

它是本地方法，作用是让字符串的引用指向字符串常量池

分两种情况

如果字符串常量池中没有这个对象的引用的话，那就创建这个对象的引用再返回，

如果字符串常量池中有这个对象的引用，那就直接返回这个引用





1. 面向对象和面向过程的区别？

解决问题的过程不同

面向对象解决问题是先抽象出对象，利用对象执行方法去解决问题

面向过程是把解决问题的过程拆成一个个方法，利用一个个方法执行解决问题

面向对象开发的程序一般更容易维护，扩展，复用，

1. 创建一个对象用什么运算符？对象实体和对象引用区别？

用new运算符，对象引用（存放在栈内存），对象实体存放在堆内存，

一个对象引用可以指向0或1个对象实体

1个对象实体可以被多个对象引用指向



1. 对象的相等和引用相等的区别？

对象的相等指的是内存中存放的内容是否相等，用equals方法

引用相等指的是内存地址是否相等，用==比较



1. 如果一个类没有声明构造方法，程序还能执行下去吗？

程序还能执行下去，因为如果我们自己没有声明构造方法，系统会在运行过程中默认生成一个无参的构造方法，然后如果我们自己有声明有参的构造方法的话，记得把无参的构造方法也写上去，避免出现莫名其妙的问题



1. 构造方法有哪些特点？是否可被override(重写)

方法名和类名一样，无返回值，也不能用void声明构造方法。在new对象的时候自动执行，无需手动调用



构造方法不能被重写，但是可以被重载



1. 面向对象三大特征？

封装，继承，多态

封装的话就是一个类隐藏自己的内部信息，外界不能直接访问这些内部消息，但是类可以提供让外界访问的getter和setter方法，就像我们使用空调，我们不知道空调的内部零件是什么，但是我们可以通过遥控器来使用空调，然后如果一个不想暴露出某个属性，就不要提供让外界访问的方法，如果一个完全没有getter和setter方法，这个类就没有意义了

继承的话，子类继承父类的信息，包括被private修饰的变量和方法，只不过子类无法访问它们，然后子类也可以有自己的属性和方法，也可以重写父类的方法

多态的话：有三个条件，一个是子类继承父类，二是子类重写父类的方法   三是父类引用指向子类实例。

所以封装和继承主要是提高程序的复用性，多态的话主要是提高程序的可移植性，高扩展性。



1. 接口和抽象类有什么共同点和区别？

共同点：

都不能直接实例化，接口需要被实现，抽象类需要被继承才能创建它们的实例对象

都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类中实现

区别：

接口主要用于约束类的行为方式，实现了某个接口就说明具有了对应的行为，而抽象类主要用于代码复用，多用于继承

Java中类是单继承（抽象类也一样），而接口可以继承多个接口，也可以实现多个接口

接口中的成员变量必须是private static final，不能修改且必须赋初始值，而抽象类中的成员变量可以被任何修饰符修饰，也可以在其子类中重新赋值





1. 深拷贝和浅拷贝了解吗？什么是引用拷贝？

深拷贝：完全复制整个对象，包括对象的内部属性

浅拷贝：会在堆上复制一个对象，并且原对象和拷贝对象共用同一个内部对象

引用拷贝：两个不同的引用指向同一个对象



1. Object类的常见方法有哪些？

getClass()

toString()

equals()

hashCode()

wait()

wait()

wait()

notify()

notifyAll()

clone()

finalize:对象被回收时执行的操作



1. ==和equals()的区别

==对基本类型来说，比较的是值，对于引用类型来说的话比较的是内存地址是否相等

equals方法的话，要看有没有重写过，如果没有重写，它等价于==，比较的是两个对象之间的内存地址是否相等，如果有重写过，像String类，比较的是两个对象的内容是否相等



1. hashCode()有什么作用？为什么要有hashCode？

hashCode可以获取哈希码，有了哈希码之后可以在哈希表中根据它找到对象，因为哈希表的结构是key,value,所以有了哈希码之后可以快速找到对象。hashCode有一些特性，两个对象的hashCode值相等不代表两个对象相等，只有两个对象的hashCode值相等并且equals方法也相等才能说明两个对象相等，然后我们就可以通过hashCode去减少equals的比较次数，提高这个比较两个对象是否相等的效率



1. 为什么重写equals()方法还要重写hashCode()方法？

   因为如果两个对象的equals方法相等的话，说明两个的hashCode先相等，并且两个对象完全相等，然后如果我们只重写了equals方法，可能会造成equals方法相等，而hashCode并不相等的情况，这样不合理

   

2. String,StringBuffer,StringBuilder的区别？

String是不可变的，而StringBuilder和StringBuffer都继承了AbstartStringBuilder,方法没有被private和final修饰，可以提供修改字符串的方法，所以是可变的

从线程安全上看，String是不可变的，相当于常量，线程安全，而StringBuilder没有对执行的方法加同步锁，线程不安全，StringBuffer的话有对执行的方法或调用的方法加同步锁，线程安全

StringBuilder的性能比StringBuffer的性能好上10-15%，但是要冒线程不安全的风险

操作少量字符串的话，用String

单线程下操作大量数据：用StringBuilder

多线程下操作大量数据：StringBuffer



1. String为什么是不可变的？

保存字符串的数组被private和final修饰，并且没有提供修改字符串的方法

因为被final修饰，不能被子类继承，避免子类破坏String的不可变



1. 字符串拼接用“+” 还是StringBuilder?

用StringBuilder,因为+操作实际上也是调用StringBuilder的append操作再通过toString方法转成字符串的。并且在JDK9之前吧，使用+操作容易创建多个StringBuilder对象，在JDK9之后，有一个动态方法可以减少创建StringBuilder对象

1. String的equals() 和 Object的equals()有何区别？

Object的equals比较的是两个对象的内存地址是否相等，等价于引用类型的双等于，而String的equals方法，因为有重写了Object的equals方法，比较的是两个对象的内容是否相等

1. 字符串常量池的作用了解吗？

JVM专门开辟出来的节约内存，提高性能的一片区域，主要目的是为了避免字符串的重复创建

1. String s1=new String("abc"),这句话创建了几个字符串对象？

可能创建1或2个字符串对象

s1会先去字符串常量池中找是否有这个对象的引用，如果有，就在堆上创建一个对象，如果没有，在堆上创建两个对象，其中一个指向字符串对象的引用

1. String的intern方法有什么用？

它是本地方法，把字符串的引用保存到字符串常量池

如果一个对象的字符串常量池中已经有了一个引用的话，执行这个方法会直接返回引用，如果字符串常量池没有这个引用，就创建一个对象并返回这个引用

1. String类型的变量和常量做“+”运算时发生了什么？

发生了一个常量折叠的优化操作。



Exception和Error有什么区别？

首先，它们都有一个共同的父类Throwable,

Exception是程序可以处理的异常，可以用catch捕获异常，它又分为Checked Exception和UnChecked Exception,受检异常，必须处理的异常和不受检异常，可以不处理的异常

而Error是程序不能处理的错误，不建议用catch捕获异常，像Java虚拟机运行时出错，虚拟机内存错误，类定义错误等，这些错误发生时，Java虚拟机一般会选择线程终止



Checked Exception和UnChecked Exception有什么区别？

Checked Exception是受检异常，程序必须处理的异常，要用catch捕获或throws关键字抛出，不然代码编译不通过，除了RuntimeException及其子类之外，其它的Exception及其子类都是受检异常，如SQLException,IO相关Exception

UnChecked Exception是不受检异常，程序可以不处理的异常，不处理也可以通过编译，像RuntimeException及其子类就是不受检异常，常见的不受检异常有空指针异常，非法参数异常



Throwable类有哪些常见方法？

getMessage() 打印异常的简要描述

toString()  打印异常的详细描述

getLocalizedMessage() 打印异常对象的本地化信息，如果Throwable的子类没有重写这个方法，它打印的与getMessage()的信息一致

printStaceTrack() 打印Throwable对象封装的异常信息



finally中的代码一定会被执行吗？

不一定，如果在finally执行之前虚拟机被终止或者程序所在的线程被关闭，关闭CPU等情况都会让finally中的代码执行不下去

异常使用有哪些需要注意的地方？

1：不要把异常对象定义成一个静态变量，这样会导致异常栈信息错乱，手动抛出异常的时候用new 一个异常对象抛出

2：记录有用的异常信息

3：尽量抛出具体的异常信息，比如你找到这个异常是sql的哪个具体异常，不要直接抛SQL异常

4：避免重复记录日志，这样不利于排查问题，也容易导致日志文件膨胀



谈谈你对泛型的理解

好的，泛型是jdk5引入的一个特性，可以在编译期间检查数据类型，减少数据类型的转换，并且我们使用泛型参数，可以提高代码的可读性和稳定性，我们使用泛型的方法有三种，泛型类，泛型方法，泛型接口。然后我们经常可以在项目中看见到的泛型有：自定义通用结果返回类，ExcelUtils<>可以动态返回excel的数据格式，以及集合工具类Collections的sort排序方法，这些就是我对泛型的理解了。



谈谈你对反射的理解？

反射是框架的灵魂，它赋予了我们运行时分析类和执行类中方法的能力，它可以获取和调用任意一个类的方法和属性。

反射的优点：让我们的代码更灵活，为框架开箱即用的功能提供了便利

缺点：存在安全问题，因为它无视泛型参数安全检查，并且性能较差，不过不影响框架的使用

反射的应用场景的话，大多是在框架，比如框架中的动态代理就是依靠反射的，还是就是在注解的时候也是依赖反射的，因为反射可以得到类运行时的属性和方法上的注解。





什么是反射？

反射是框架的灵魂，它赋予了我们运行时分析类和执行类中方法的能力，它可以获取和调用任意一个类的属性和方法

反射的优缺点？

优点：让我们的代码更灵活，为框架开箱即用的功能提供了便利。

缺点：带来了安全问题，因为它无视了泛型参数的安全检查，并且执行性能稍差，不过不影响框架

应用场景

框架，框架中的动态代理也是依靠反射，还有注解，我们可以通过反射分析类，得到这个类中的注解





注解是什么？

注解本质上是一个继承了Annotation的接口，它可以看作是一个特殊的注释，然后注解可以用于修饰类，方法，变量，提供某些信息让程序在编译或运行时使用。Java中有许多内置注解（@Override），我们自己也可以自定义注解



注解的解析方法有哪几种？

注解只要被解析之后才会生效，常见的注解解析方法有两种，

一种是编译期直接扫描，编译器在扫描Java代码时会扫描对应的注解并处理，比如扫描到@Override注解，就会判断这个方法是否有正确重写父类的方法，如果没有，就会发出编译警告。

第二种注解解析方法是通过反射处理，很多框架都是通过反射处理的，比如spring框架的@value，@Component























谈谈你对注解的理解？

注解本质上是一个继承了Annotation的接口，可以把它看成是一个特殊的注释，它使用在类，方法，变量上面，提供某些信息给程序编译或运行时使用。Java中有许多内置注解，像@Override,我们自己也可以自定义注解。

然后注解需要被解析之后才能使用，常见的有两种注解解析方法，第一种是编译期直接扫描，编译器在扫描Java代码时扫到对应注解时处理，比如扫描到@override注解，会去判断它是否正确重写了父类的方法，如果没有正确重写，会报编译警告

第二种解析方法是通过反射处理，很多框架都是通过反射处理，比如spring框架的@Value，@Component注解

然后我在项目中有使用到一个自定义注解，可以让判断用户的权限。然后加在Controller方法上的话声明下注解就可以了



什么是SPI？

专门提供给服务提供者或有扩展框架能力的开发者去使用的接口，它可以把接口和具体实现分离开，把服务提供者和服务调用者解耦，提高程序的扩展性和可维护性，JAVA的一些框架有使用到了SPI机制，比如spring框架，dubbo的扩展机制

API和SPI有什么区别？

API是实现方提供好接口，调用者去调用接口，就可以使用实现方提前写好的功能

SPI是服务调用者制定了规范，实现方需要按照规范去执行，然后提供服务



什么是序列化？什么是反序列化？

序列化是将数据结构或对象转换成二进制字节流

反序列化是将序列化过程中生成的二进制字节流转成数据结构或对象

像是JAVA中，序列化和反序列化都是用对象去做转换的

而在C++中，结构体定义的是数据结构，class对应的是对象类型

序列化的主要目的是通过网络传输对象或是将对象存进文件系统，数据库，内存等。

像我们使用redis需要把对象序列化，从redis中取出来就需要反序列化把对象拿出来



序列化协议是在那一层？

在OSI七层模型的表示层，表示层属于TCP/IP协议的应用层



如果有些字段不想序列化的话怎么办？

可以用transient关键字修饰，不过使用它的话有一些注意事项，

它只能修饰变量，不能修饰类和方法

静态变量属于类，不属于实例，无论有没有被transient关键字修饰，都不会被序列化

反序列化时，被它修饰的变量会恢复成类型的默认值，比如int会被恢复成0



谈谈你对SPI的理解吧

SPI是专门提供给服务提供者或有扩展框架能力的开发者去使用的一种接口。它可以将接口和具体实现类分离开来，让服务调用者和服务实现者之间解耦，让程序具有扩展性，可维护性，不过它的缺点有一些缺点，需要遍历加载所有的实现类，不能做到按需加载，并且当多个ServiceLoad同时加载，会有并发问题，然后它跟API的区别的话，API是接口实现者实现好接口，调用者调用接口就可以使用实现者提前写好的功能，而SPI是接口调用者制定好规则，接口实现者按照这个规则去实现。



常见的序列化协议有什么？

有JDK自带的序列化协议，但是性能差并且存在安全问题，常用的话是Hession,Kryo,protobuf,protostuff,

然后像JSON，XML种序列化协议，可读性好，但是性能也是稍差，也不怎么选择



为什么不推荐使用JDK自带的序列化？

1：不支持跨语言调用

2：性能较差，比起其它的序列化协议来说的话，生成的字节数组体积较大，不利于传输

3：存在安全问题，反序列化后的数据可以被用户操作，如果有人心怀不轨，就挺危险的。



了解序列化和反序列化吗？

序列化是把数据结构或对象转换成二进制字节

反序列化是把序列化中生成的二进制字节转换成数据结构或对象

序列化的主要目的是通过网络传输对象或把对象保存到文件系统或数据库，内存中

在Java中使用序列化的是对象，而像C++里面，结构体使用的是数据结构，类才是定义的对象

我们在项目中使用序列化的地方，把文件持久化，读文件需要反序列化，把对象存储进redis序列化，把序列化后的对象读出来需要反序列化

常见的序列化协议有JDK自带的序列化，不过它不支持跨语言调用，性能较差，存在安全问题，所以不使用，然后其它比较常用的序列化协议的话：Hession,Kryo,protobuf,protostuff等,然后像JSON和XML的序列化协议，虽然可读性好，性能稍差，也是不怎么常用

如果有字段不想通过序列化的话，可以用transient关键字，它的作用让字段不能通过序列化，并且反序列化之后的字段不能被持久化和恢复

序列化协议位于OSI七层模型的表示层，表示层是属于TCP/IP协议的应用层





java的io流了解吗？

IO是input和output，输入和输出，数据输入到计算机内存的过程叫做输入，把数据输出出外部存储（比如数据库，文件）的过程叫做输出，因为传输过程类似于水流，因此叫做io流。io流在Java中被分为输入流和输出流，根据数据的处理方式，又可以分为字节流和字符流

IO流的4个基类是

InputStream,OutputStream是字节流的输入流和输出流

Reader,Writer是字符流的输入流和输出流



IO流为什么要分为字节流和字符流？

字符流是由Java虚拟机将字节转换得到的，这个过程比较耗时；

如果我们不知道编码类型，使用字节流很可能出现乱码问题



说说你对语法糖的了解？

语法糖是编程语言为了方便程序员开发程序而设计出来的一种特殊语法，不会影响到编译语言的功能。使用语法糖可以让我们的程序看起来简介和可读性更强。然后JVM不能识别语法糖，需要通过java编译器去进行解糖操作后才能转换成JVM能识别的语法，主要是用到一个Compiler类的desugar()方法

常用的语法糖的话主要由8种，增强for循环，try-with-resource,lambda表达式，泛型，可变长参数，枚举，内部类，自动拆装箱



集合概述？

Java集合，也叫做容器，主要是由两大接口派生而来，一个是Collection接口，用于存储单一元素，另一个是Map接口，主要用于存放键值对，Collection接口的话下面由三个主要的接口，List,Set,Queue

List,Set,Queue,Map之间的区别？

List存储的元素是有序，可重复的，可以存多个null值，元素可以通过索引访问

Set存储的元素是无序，不可重复的，只能存一个null值，这里的无序主要是针对HashSet集合不能根据添加顺序排序，也不能根据自然顺序a-z排序，其它的实现类是可以实现有序的，set集合只能通过元素本身去访问

Queue主要是按照特定的规则去排序的，存储的元素也是有序可重复的

Map存储的是键值对，key是无序，不可重复，value的话无序可重复，每个key最多映射一个value



Collection集合下的底层数据结构

List:

ArrayList: Object[]数组

LinkedList: 双向链表（JDK1.6之前是循环链表，1.7取消了循环）

Vector: Object[] 数组



Set:

HashSet: 底层基于HashMap实现，使用hashMap保存数据

LinkedHashSet: 它是HashSet的子类，底层基于LinkedHashMap实现

TreeSet:红黑树



Queue：

priority Queue：Object[]数组实现小顶堆

DelayQueue: priorityqueue

ArrayDeque:  可扩容动态双向数组



Map下面的集合：
HashMap: JDK1.7之前由数组+链表组成，数组是主体，链表是用于解决哈希冲突用的，JDK1.7之后，如果链表小于阈值（默认是8），会将链表转成红黑树，减少搜索时间，不过在转成红黑树之前，会对数组进行判断是否小于64，小于的话会先进行扩容操作

LinkedHashMap:继承HashMap,底层也是数组+链表或红黑树组成，不过它新增了一条双向链表，可以确定键值对的插入顺序，又通过对链表的操作，实现访问数据顺序相关逻辑

HashTable: 数组+链表，数组是主题，链表解决哈希冲突

TreeMap: 红黑树



如何选用集合？

根据集合的特点去选，比如需要根据键获取到值，选Map集合，需要有序的话选TreeMap,无序的话选HashMap,然后需要线程安全的话就选ConcurrentHashMap

如果只需要存放单一元素的话，你就选Collection集合，像List的话有序可重复，Set无序不可重复，Queue根据特定的规则确定排序，存储的元素也是有序可重复



为什么要使用集合？

因为在实际开发中，我们需要的数据类型是多种多样的而且数量也不确定，这时我们的选择可以有数组和集合两种，不过数组不适合在这里使用，因为数组大小不可变，也不能同时存各种类型的数据，所以我们就选择集合了，集合的优势的话，动态数组，支持泛型，具有内建算法，提高了数据的存储和灵活性，最主要是提高了程序的开发效率





















谈谈你对集合的了解。

Java中，集合也被叫做容器，它主要有两大接口派生而来，Collection和Map接口，前者主要是用于存储单一数据，后者的话主要是用与存储键值对的。Collection下常见的三个接口是List,Set,Queue。

集合的优势的话主要是大小可变，支持泛型，具有内建算法，可以提高数据的存储和灵活性，提高程序开发的效率。

然后项目中比较常用的集合类型的话ArrayList,HashMap, 

ArrayList的话，它的底层是Object[]数组，

而HashMap的话，在JDK1.8之前是数组+链表，数组是它的主体，链表是为了解决哈希冲突用的，在JDK1.8之后，如果链表长度小于阈值（默认是8）会把链表转成红黑树，提高搜索时间，不过在转成红黑树之前还会对数组长度判断是否小于64，小于的话会先对数组进行扩容操作

ArrayList和Array有什么区别？

ArrayList是动态数组，Array是静态数组，前者使用起来更方便和灵活。

ArrayList创建时不需要指定大小，数组创建时需要指定大小

ArrayList可以根据存储的元素动态地扩容或缩容，数组在创建后就不能修改长度了

ArrayList支持泛型，数组不支持

ArrayList中存放的是对象和包装类型，数组存放的是对象和基本类型

ArrayList有丰富的API操作元素，数组只能通过索引访问和遍历元素，其它操作需要自己手动执行



ArrayList中可以添加null值吗？

可以添加，不过不建议添加，因为添加null值之后如果不做判空处理，会抛空指针异常、



ArrayList插入和删除的时间复杂度？

从头部插入的话：因为所有元素都要往后移一位，所以是O(n)

从尾部插入的话：不需要移动元素，O(1)

从指定位置插入的话：插入位置之后的元素都需要往后移一位，相当于需要移动二分之n个元素，时间复杂度也是O(n)



删除的话和插入的时间复杂度一样，不过原理是删除之后的元素都需要往前移动而已





ArrayList和LinkedList的区别？

底层数据结构不同：ArrayList是Object[]数组实现，LinkedList是双向链表

插入和删除方面：前者插入和删除麻烦，查询简单，后者是插入和删除简单，查询麻烦

前者支持随机快速访问，后者内存地址不连续，没法实现RandomAccess接口，不支持随机访问

前者会在数组的末尾留下一定的容量，后者每一个元素的前驱和后继都需要消耗容量，它花费的比前者花的太多了



HashMap与HashTable的区别？

HashMap线程不安全，HashTable线程安全

因为线程不安全，HashMap的执行效率比HashTable高

HashMap底层数据结构是数组+链表+红黑树，   HashTable的底层是数组+链表

HashMap支持null key和null value,null只能有一个，HashTable不支持nullkey和null value

HashMap不赋初值时候默认容量是16，扩充容量是2n+1, 

HashTable不赋初值时候默认容量是11，扩充容量是2n, 

赋初值时 HashMap会把初始值扩充为2的幂次方 HashTable直接把初值作为默认容量

HashMap的hashCode经过高位和低位的扰动处理去减少冲突，而HashTable的hashCode值是默认的hashCode,没经过优化处理



HashMap的长度为什么是2的幂次方？

因为哈希值的范围太大，内存放不下，我们可以想到通过对数组的长度进行求余操作得到元素的存放位置，然后如果hashmap的长度是2的幂次方的话，求余操作可以等价于数组的长度-1  & hash，&操作的性能比%操作性能好，更快计算元素的存放位置。

HashMap为什么线程不安全？

JDK1.7之前，多线程环境下，hashMap进行扩容操作会造成死循环和数据丢失的风险

JDK1.8，多个键值对可能被存放在同一个桶中，它们被存放在链表或红黑树里，多线程情况下执行put操作，可能会造成数据覆盖。



Comparable和Comparator的区别？

它们都是Set集合中用于排序的接口，在比较类对象大小，排序方面发挥了作用

Comparable有一个compareTo方法

Comparator有一个compare方法

当我们需要对一个集合进行排序，可以重写compareTo或compare方法

当我们需要对一个集合进行两种排序，可以重写compareTo方法和使用自定义的comparator方法，或者使用两个自定义的comparator方法



Set集合下的HashSet,LinkedHashSet,TreeSet有什么相同点和区别？

相同点：它们都是Set集合的实现类，都能包装元素的顺序唯一，都线程不安全。

区别：它们主要的区别是底层的数据结构不同

HashSet底层是HashMap,适用于对插入顺序和取出顺序不要求的场景

LinkedHashSet底层是LinkedHashMap，适用于对插入顺序和取出顺序满足FIFO（先进先出）的场景

TreeSet底层是红黑树。 适用于自定义排序的场景



HashMap与HashSet的区别？

HashMap实现了Map接口，存储键值对， HashSet实现Set接口，存储单一元素

HashMap使用put方法添加元素，  			HashSet使用add方法添加元素

HashMap使用key计算hashCode,				HashSet使用成员对象计算hashCode



HashSet任何检查重复？

先通过HashCode()计算两个元素哈希值是否相等，不等的话直接插入，相等的话再比较一下equals方法是否相等，因为Object的equals方法是比较的两个对象的内存地址是否相等，equals方法比较完不等的话才插入。

然后在JDK1.8的时候，add()方法不管你元素是否相等，都会直接插入HashSet的，不过会在方法的返回值告诉你插入之前是否相等。



ConcurrentHashMap与HashTable的区别？

它们主要是实现线程安全的方式不同。

从底层数据结构来看：

ConcurrentHashMap在JDK1.7的时候是分段的数组+链表 ，在JDK1.8的时候是数组+链表或红黑树

而HashTable的底层数据结构一直是数组+链表，数组是它的主体，链表用于解决哈希冲突

从实现线程安全的角度来看：

ConcurrentHashMap在JDK1.7是使用分段锁，锁住容器数据，多线程访问不同数据段的容器数据，不会造成线程冲突，在JDK1.8的时候，优化成使用synchronized关键字和CAS操作

而HashTable实现线程安全则是使用synchronized 关键字修饰，当多线程访问同一个方法时，进入阻塞和轮询状态，效率较差

ConcurrentHashMap为什么不允许使用将key和value作为null

因为将key和value作为null会产生歧义，比如说这个null究竟有没存在于集合，还是说返回的结果就是null

然后单线程下可以容忍歧义，但是多线程下不能容忍，因为可能造成数据的混乱



ConcurrentHash可以保证复合操作的原子性吗？

无法保证，因为线程可能在执行过程中被另一个线程中断，导致结果不和预期结果一致。

然后如果想保证复合操作的原子性的话，可以选择ConcurrentHash提供的一些API，它有做操作保证复合操作的原子性，或者也可以选择synchronized关键字，不过这个不推荐就是了



什么是spring框架？

spring框架是一款开源的轻量级Java开发框架，它是很多模块的集合，比如说IOC和AOP，支持访问数据库，还有集成第三方组件，使用spring框架可以提高我们的开发效率和提高系统的可维护性



spring有哪些模块？

Core container:核心容器

AOP:面向切面编程   Aspect:AOP思想的具体实现

Data Access/    数据访问/数据集成

Web  //web相关

Test   //测试





IOC：控制反转,原来我们需要new对象，现在把new对象的事情交给IOC容器去做，这样做的好处是可以解耦合，用xml,和注解等方式去做控制反转的

IOC容器：负责对象的创建，初始化等一系列工作，在IOC里面的对象叫做Bean,

DI：依赖注入，在IOC容器中，如果两个bean之间有依赖关系，IOC容器给你绑定好



谈谈你对AOP的了解？

AOP是面向切面编程，它的本质是代理模式，如果要代理的对象有实现某个接口的话，会用JDK Proxy代理，如果没有实现某个接口，则会用cligb生成一个被代理对象的子类去代理。AOP做的事情是不侵入代码的前提下增强功能，它主要与五个东西有关，连接点，切入点，通知，通知类，切面





spring,springmvc,springboot之间什么关系？

spring是spring framework，它是很多模块集合，比如IOC和AOP，数据访问，支持第三方组件阿。然后springMVC是依靠spring框架的IOC去实现的，它是一个表现层框架，帮助我们开发web程序的，并且springmvc还提供了异常处理器和拦截器，M是model，V是view，C是controller，这样将数据和显示分离，让我们的开发更加清晰。然后spring boot是用于简化spring配置的，因为spring框架的使用要么在xml文件，要么在注解里面声明，配置很多且不方便，springboot简化成只在yml或yaml中配置即可



springMVC的核心组件是什么？

DispatcherServlet:核心的中央处理器，负责接收请求，分发，响应客户端

HandlerMapping:处理器映射器，根据请求的url找到对应的handler

HandlerAdaptor:处理器适配器，执行对应的handler

hander:请求处理器，执行实际的方法

ViewResolver:视图解析器，解析结果，返回给DispatcherServlet响应客户端



1. Java集合概览

JAVA集合，也叫做容器，主要由两大接口派生而来，一类是Collection,用于存放单一元素，一类是Map，用于存放键值对

Collection下由三个主要的子接口，List,Set,Queue

1. 说说List,Set,Queue,Map的区别？

List存储的元素是有序可重复的，可以存null，可以通过索引访问

Set存储的元素是无序，不可重复，可以存一个null，只能通过元素本身访问

Queue是按照特定的规则排序的，存储的元素也是有序可重复

Map存储的是键值对，key存的是无序不可重复的，value存的是无序可重复的，每个key最多映射到一个值



1. Collection下面的集合底层数据结构

LIst

ArrayList:Object[]数组

LinkedList:双向链表（JDK1.7之前是循环链表，JDK1.7取消了循环）

Vector:Object[]数组

Set

HashSet:底层基于HashMap,数组+链表+红黑树

linkedHashSet：是HashSet的子类，基于LInkedHashMap,数组+链表+红黑树

TreeSet:红黑树，（默认升序排序）





Queue

PriorityQueue:Object[]数组实现小顶堆

DeDeque:基于PriorityQueue

ArrayDeque:可扩容动态双向数组





1. Map下面的集合底层数据结构

HashMap:JDK8之前由数组+链表组成，数组是它的主体，链表是为了解决哈希冲突用的，到JDK1.8后由数组+链表+红黑树组成，当链表长度大于8时会将链表转成红黑树，提高搜索时间，不过在转成红黑树之前会判断数组长度是否小于64，小于的话会进行扩容操作

LinkedHashMap：数组+链表+红黑树，不过多了一条双向链表，可以确定键值对的插入顺序，实现访问顺序相关逻辑

HashTable: 数组+链表，数组是主体，链表是解决哈希冲突用的

TreeMap:红黑树



1. 如何选用集合？

根据集合的特点去选，比如需要存放键值对的就选Map下面，需要有序的话选TreeMap,需要线程安全的选ConcurrentHashMap

需要存放单一元素的就选Collection下面的元素，需要有序可重复就选ArrayList,无序不可重复就选HashSet



1. 为什么要使用集合？

实际开发中我们需要存储一批多种多样然后数量不确定的数据，这个时候由数组和集合两种方式，不过集合相比较于数组的话有一些优势，比如动态大小，支持泛型，具有丰富的API操作，这些都是数组无法比拟的。使用集合可以提高我们开发程序的效率



1. ArrayList和Array(数组) 有什么区别？

ArrayList是动态数组，Array是静态数组，前者使用起来更方便

ArrayList创建时不需要指定大小，数组需要

ArrayList可以动态地扩容和缩容，数组不行

前者支持泛型，后置不支持

前者有丰富的API方法，后者只能通过索引去遍历和访问元素，其它操作需要自己实现

ArrayList中存放的是对象和包装类型，数组中存放的是对象和基本类型



1. ArrayList 和 Vector的区别 （了解）

ArrayList线程不安全，Vector线程安全

1. ArrayList中可以添加null值吗？

ArrayList中可以添加任何类型的数据，包括null值，但是不建议添加null值，因为如果你不做判空处理的话容易出现空指针异常

1. ArrayList插入和删除的时间复杂度
2. LinkedList插入和删除的时间复杂度
3. LinkedList为什么不能实现RandomAccess接口？

RandomAccess接口是根据索引快速查找元素的能力，而LinkedList底层是数组+链表，内存地址不连续，不能够实现



1. ArrayList与LinkedList的区别？

底层不同：前者是动态数组，后者是数组+链表+红黑树

​					前者是查询快，增删慢	后者是增删快，查询慢

​				前者支持快速访问，后者无法实现RandomAccess接口，无法根据快速访问

​				ArrayList会在数组的末尾预留一定的容量，而LinkedList则是在每个元素都会有前后指针，消耗比ArrayList更多的容量	





1. ArrayList的扩容机制是什么？

会先计算出要扩容的数组的长度，默认是1.5倍，然后把原来数组的数据搬迁到扩容后的数组的里面，然后更新原来数组的地址引用。然后如果扩容后还是放不下的话， 那就以实际数组长度为准

它是依靠内部的ensurecapacity操作，先判断数组是否需要扩容，需要的话再调用grow方法再实际执行上述操作

1. Set集合中Comparable接口和Comparator接口区别？

它们都是Set集合中用于排序的接口，Comparable中需要实现一个compareTo的方法，Comparator的话需要实现compare方法，

当我们需要对一个集合进行排序，可以重写compareTo方法或者重写compare方法

当我们需要对一个集合进行两种排序，可以重写compareTo方法和使用自定义的comparator方法，或者使用两个自定义的comparator方法



1. Set集合中无序性和不可重复性指的是什么？

无序性不是指随机性，插入顺序和取出顺序不一致，它主要是内部存的时候是用哈希值对数组长度求余得到的索引位置，不像ArrayList那样是按照数组的内存地址排序

不可重复性指元素唯一，利用equals方法比较，相同则代表重复



1. 说说HashSet,LinkedHashSet,TreeSet的异同？

相同点：都是Set集合的实现类，元素都不能重复，无索引

不同：主要是底层的数据结构不同，导致应用场景不同

HashSet：底层是HashMap，适用于对元素的插入顺序和取出顺序无关的场景

LinkedHashSet:底层是LinkedHashMap,适用于对元素的插入顺序和取出顺序满足FIFO（先进先出）的场景

TreeSet底层是红黑树，适用于对元素自定义排序的场景



1. Queue与Deque的区别？
2. ArrayDeque和LinkedList的区别？