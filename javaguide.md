# Java基础（上）

## java语言有什么特点？

1:简单易学

2：面向对象（封装，继承，多态）

3：跨平台性（Java虚拟机实现平台无关性）

4：可靠性（Java具有异常处理机制和自动内存管理机制）

5：内置多线程（像C++没有内置多线程，要用操作系统的多线程功能实现，而Java内置了多线程）

6：安全性（Java语言的设计就提供了多重安全防护机制如访问权限修饰符，限制程序直接访问操作系统资源）

7：高效性（有Just in time等编译器的优化，Java的执行效率不错）

8：支持网络编程并且很方便

9：编译与解释共存

## JAVASE与JAVAEE

JAVASE:基础版本

JAVAEE:企业版本

JAVAME:微型版本，无需关注



## JVM&&JDK&&JRE

JVM，是Java虚拟机，是运行字节码文件的虚拟机，它有针对不同系统的特定实现，目的是使用相同的字节码文件，在不同的操作系统下给出相同的结果，字节码文件和不同系统的JVM是Java语言“一次编译，随处可以执行”的关键



JRE包含Java运行时环境和必要的类库， JDK包含了JRE和像JavaC,javadoc等工具



JVM是Java虚拟机，Java程序（.java）文件经过javac编译器成功后生成.class文件，这个文件被Java虚拟机执行后就生成了我们所看到的结果。



## 什么是字节码？采用字节码文件的好处是什么？

JVM可以理解的代码就是字节码，即.class文件，采用字节码文件好处

1：在一定程度上解决了传统型解释型语言执行效率低的问题，保留了解释型语言可移植性的特点，所以运行时相对高效

2：一次编译，随处可以执行

## 为什么说Java语言编译与解释共存?

首先，编译型语言是一次性把代码翻译成机器码再执行，这样的话执行速度快，开发效率低，像C，C++就是编译型语言

​	而解释型型语言是边解释边执行，这样的话是开发效率快，执行速度慢，像python，JavaScript就是解释型语言

然后Java语言既具有编译性语言的特点，又具有解释型语言的特点，Java语言是先编译，后解释，先把Java程序编译成.class文件,又通过Java解释器或JIT编译器进行解释



## JAVA和C++的区别?

JAVA与c++都是面向对象,都具有封装,继承,多态,

但是1:Java没有指针直接访问内存,程序内存更加安全

​	2:Java的类是单继承,C++支持多重继承,虽然Java的类不可以多继承,但是接口可以多继承

​	3:C++具有方法重载和操作符重载,Java只支持方法重载,因为操作符重载太复杂,与最开始要设计的思路简单不合.

​	4:Java自动内存管理垃圾回收机制(GC),程序员无需手动释放无用内存



## 注释有哪几种?

单行注释

多行注释

文档注释



## 标识符和关键字区别?

标识符就是用来起名字的,给类,方法,变量等,组成是以数字,字母,下划线_或美元符号$,然后不能以数字开头,也不能是关键字去命名

关键字就是被赋予了特殊意义的标识符,比如private,class之类,然后注意下关键字都是小写开头的,

true,false,null看起来像关键字,但是他们实际上是字面值,但是也不能作为标识符使用



## 自增自减运算符

b=a++ ,b=a ,a=a+1  

b=++a b=a+1,a=a+1



## 移位运算符

左移<<,高位丢弃，低位补0，有时候相当于乘2，但是有时可能变成符号相反，正数变负数，还有一种情况，比如int是32位的，你左移32位，要先对32位求余，再进行左移

带符号右移>>，分两种情况，正数右移和负数右移，正数右移是低位丢弃，高位补0，负数右移是先求补码，低位丢弃，高位补1，然后按位取反+1才得到结果

无符号右移>>>，正数：低位丢弃，高位补0，负数：先求补码再低位丢弃，高位补0

double和float两种不能进行移位，移位运算符支持的只有int和long类型,其它类型如short，byte，char会转成int再操作,

超过位数的话会先对数进行求余在移位,如int对32求余,float对64求余



## continue,break,return的区别?

continue:跳出这次循环,进入下一次循环

break:中止循环,执行循环下面的语句

return:两种用法,1:return;不带返回值终止程序

​							 2:return value;带返回值终止程序



## 基本类型和包装类型的区别?

1:用途:除了常量和局部变量之外,在其它地方比如方法参数,对象属性很少使用基本类型,并且包装类型可以作为泛型,基本类型不行

2:存储方式:基本类型的局部变量存储在Java虚拟机栈中的局部变量表中,(未被static修饰的)成员变量存储在Java虚拟机堆中,被static修饰的成员变量也存放在堆中，但属于类，不属于对象，而包装类型属于对象类型,几乎所有对象实例都是存储在堆中

3:占用空间:相比较与包装类型,基本类型的占用空间往往非常小

4:默认值:成员变量的包装类型不赋值就是null,而基本类型有默认值且不为null

5:比较方式:基本类型的值比较方式是用==  ,而包装类型用==比较的是内存地址,要想比较包装类型的值的话,得用equals()方法



为什么几乎所有对象实例都存放于堆中？

因为HotSpot虚拟机引入了JIT优化后，会对对象进行逃逸分析，如果发现某一个对象没有逃逸到方法外部，可能会用标量替换的方法实现栈上分配，避免堆上分配内存



## 包装类型的缓存机制了解吗?

包装类型大部分都使用了缓存机制提升性能,

比如Byte,Short,Integer,Long 这四个创建了[-128,127]范围内的数值,Chracter创建的[0,127]范围内的,Boolean类型返回的true或false,Double类型和Float类型则没有使用缓存机制,

只要在这部分范围内的数值,都是使用缓存中的对象,不然就是创建一个新的对象,但是要注意虽然两个数值都是缓存中的对象,只有数值相等才会缓存成同一个对象,不然就是缓存成不同的对象



Integer i1=40;

它等于Integer i1=Integer.valueOf(40)



## 自动装箱与自动拆箱了解吗?原理是什么?

装箱:把基本类型变成包装类型 Integer i=1;  等价于 Integer i=Integer.valueOf(1);

拆箱:把包装类型变成基本类型 int j=i;            等价于int j=i.intValue();

装箱利用了valueOf()方法

拆箱利用了xxxValue()方法

然后要注意不能频繁拆装箱,很影响系统性能



## 为什么浮点数运算会有精度丢失的风险?如何解决浮点数运算的精度丢失问题?

这个和计算机保存浮点数的机制有关,因为计算机是二进制的,然后如果遇到无限循环的小数的话,因为宽度有限,只能进行截断操作,所以存在精度丢失的风险.

解决问题的话可以使用一个Bigdecimal,他不会造成精度丢失,然后在一些业务场景,比如涉及钱的,经常使用这个Bigdecimal



## 超过long整形的数据如何表示?

BigInteger,它内部使用的int[]数组来表示任意大小的整数数据,但是他相对于正常整数类型的运算来说的话,它的运算效率相对低



## 成员变量与局部变量的区别？

1：语法形式：成员变量是属于类的，而局部变量是代码块或方法内定义的变量或方法的参数，然后成员变量可以被private,public,static等修饰符修饰，局部变量不行，但是他们都能被final修饰

2：存储方式：从内存的存储方式来看，未被static修饰的成员变量是类，被static修饰的成员变量是对象实例，对象存在于堆内存，局部变量存在于栈内存

3：生存时间：成员变量是对象的一部分，成员变量随着对象的创建而创建，变量的生存时间是随着方法调用而创建，随着方法调用结束而消亡

4：默认值：成员变量未赋初始值时会自动根据类型默认值赋值，比如基本类型int会被自动赋成0，包装类型的话会被赋为null，（被final修饰的成员变量必须显示地赋值），而局部变量未赋初值时不会自动赋值，但是打印语句会显示没有初始化。



为什么成员变量有默认值？

首先，变量存储的是内存地址对应的随机任意值，如果没有默认值，程序读取该值运行时会出现意外

然后默认值有两种赋值方法：手动和自动，成员变量可以通过反射等方法为变量手动赋值，而局部变量不行

编译器（javac）通过检查，发现局部变量没赋值，可以直接报错，但是成员变量不行，它可能是运行时通过反射赋值，对成员变量处于一种报错不行，不报错又可能没赋值，于是自动赋默认值



## 静态变量有什么作用？

静态变量是被static修饰的变量，通过类名.变量使用，然后无论一个类创建了多少个对象，静态变量只会被分配一次内存，这样可以节省内存，通常情况下，静态变量会被final修饰成常量



## 字符型常量和字符串常量的区别？

1：形式：字符型常量是用单引号括起来的单个字符，字符串常量是用双引号括起来的0个或多个字符

2：含义：字符型常量相当于一个ASCII值，可以参与表达式运算，字符串常量代表一个地址值

3：内存：字符型常量占两个字节，字符串常量占若干个字节



## 什么是方法的返回值？方法有哪几种类型？

方法体中的代码执行后产生的结果，如果有返回值的话，返回值的作用是接收结果，让它用于其它操作

按照方法的参数和返回值分：

方法有四种类型，无参无返回值，无参有返回值，有参无返，有参有返



## 静态方法为什么不能调用非静态成员？

静态方法是属于类的，在类加载的时候分配内存，此时就可以通过类名.方法调用了，而非静态成员变量是属于对象实例的，需要在对象实例化之后才能调用它，也就是说静态方法存在的时候非静态成员还没出生，这样去调用是非法操作，会报错



## 静态方法和实例方法有什么不同？

1：调用方式不同，静态方法可以使用类名.方法去使用，也可以使用对象.方法去使用，而实例方法只有对象.方法去使用，然后静态方法是属于类的，尽量不要用对象.方法去调用，容易造成混淆

2：访问类成员变量的限制：静态方法不允许访问非静态成员变量和非静态方法，然后可以访问普通的成员变量和方法，然后实例方法就没有这个限制



## 方法重载和方法重写有什么不同？

重载：方法名相同，根据输入数据的不同，返回不同的处理

重写：子类继承父类的相同方法，输入相同的数据，返回不同的响应

具体来说，重载就是要求方法名相同，然后参数数量，参数类型，参数顺序有一个不同，就是方法重载，跟方法的返回值和访问权限修饰符无关，方法重载可以重载任何方法。

重写呢，就是子类继承父亲的相同方法，然后有两同两小一大的要求

方法名和参数类别相同

返回值小于或等于父类方法的返回值，异常也是小于或等于父类方法的异常

访问权限修饰符大于或等于父类的访问权限修饰符

注意父类的构造方法和被private，final，static修饰的方法都不能重写，还有父类返回值是void和null的话，子类也是一样，父类如果是引用类型的话，子类可以返回该引用类型的子类



## 什么是可变长参数？

调用方法时可以传入不定数量的参数作为参数值，定义的话是类型...，然后需要注意的是它只能写在参数列表的最后，只有单它一个可变长参数时才写在前面，

最后的话遇到方法重载的时候，会优先匹配固定参数的函数而不是有可变长参数的函数，还有它被编译后实际上是变成了数组的



# Java基础（中）

## 面向对象和面向过程的区别？

解决问题的方式不同

面向对象是抽取出对象，然后用对象执行方法解决问题

面向过程是把解决问题的过程拆成一个个方法，利用一个个的方法执行解决问题

面向对象开发的程序一般易维护，易扩展，易复用



## 创建一个对象用什么运算符？对象实体和对象引用区别？

new运算符，new对象实例（存放在堆中），对象引用指向对象实例（对象引用存放在栈内存中）

一个对象引用有0或1个对象

一个对象可以被n个引用指向



## 对象的相等和引用相等的区别？

对象的相等是比较内存中存放的内容是否相等，用equals()方法

引用相等是比较指向的内存地址的地址是否相等，用==比较



## 如果一个类没有声明构造方法，程序还能执行下去吗？

首先，构造方法作用是用于完成对象的初始化工作的，如果没有声明的话，它会默认生成一个无参的构造方法，程序可以继续执行下去，如果有自己有重载有参的构造方法的话，最好把无参的构造方法也写上去，这样可以在创建对象的时候少踩坑。



## 构造方法有哪些特点？是否可被override(重写)

方法名和类名一样，无返回值，且不能用void声明构造方法，在new对象的时候自动执行，无需手动调用，

它不能被override（重写），但是可以被overload(重载)



## 面向对象三大特征？

封装，继承，多态

封装就是把一个对象的状态信息隐藏在对象内部，外部不能直接访问对象的内部信息，但是可以提供让外界访问的方法，就像使用空调，我们不知道空调内部的零件，但是我们可以通过遥控器使用空调，然后属性要是不想被访问，就不要提供给让外界使用，然后一个类要是完全没有提供让外界访问的方法，那这个类没有意义了

继承的话，子类会继承父类的所有属性和方法，包括private修饰的，但是不能访问这些部分，子类可以拥有自己的属性和方法，子类可以重写父类的方法

多态的条件有三个，一：要有继承，二：子类需要重写父类的方法，三：父类引用指向子类实例

封装和继承让代码更复用，多态的话是让代码更容易移植，也更健壮



## 接口和抽象类有什么共同点和区别？

共同点：

​	都不能被实例化

​	都可以有抽象方法

​	都可以有默认实现的方法

区别：

​	接口用于对类的行为进行约束，实现了某个接口就具有了对应的行为，而抽象类是用于代码复用，强调所属关系

​	一个类只能继承一个类，但是可以实现多个接口

​	接口中的成员变量只能用public static final修饰，不能修改且必须赋值，而抽象类的成员变量用default修饰，可以在子类被重新定义，  	也可重新赋值



## 深拷贝和浅拷贝了解吗？什么是引用拷贝？

深拷贝：完全复制整个对象，包括对象的内部对象

浅拷贝：会在堆上创建一个新的对象，如果原对象内部有引用类型，复制的是内部对象的内存地址，也就是说，拷贝对象和原对象共用同一个内部对象

引用拷贝：两个不同的引用指向同一个对象



## Object类的常见方法有哪些？

getClass()

hasCode()

equals()

clone()

toString()

notify()

notifyAll()

wait(超时时间)

wait(超时时间，额外时间)

wait()

finalize():



## ==和equals()的区别

对于基本数据类型来说，==比较的是值

对于引用数据类型来说，==比较的是对象的内存地址是否相等

equals的话要分两种情况，一种是没有重写equals的，那它是等价于==，另一种是有重写equals的，比如String类，比较的是值是否相等



## hashCode()有什么作用？

获取哈希码，哈希码的作用是确定对象在哈希表中的索引位置，哈希表存储的是键值对，根据这个key可以快速找到所需要的对象



## 为什么要有hashCode？

以HashSet举例，如果两个对象的hashCode值不等，可以直接加入HashSet,如果hashCode值相等，还要通过equals比较，如果equals还相等，说明两个是同一个对象，不等就加入HashSet,这样可以减少equals次数，可以提高执行速度



## 为什么重写equals()方法还要重写hashCode()方法？

首先，两个对象之间的equals方法相等也代表两个对象之间的hashCode值也是相等的，因为hashCode值相等可能是哈希碰撞，并不能说明两个对象相等，如果只重写equals方法而不重写hashCode方法，可能导致equals方法相等，但是hashCode值却不相等



## String,StringBuffer,StringBuilder的区别？

分三个方面：

1：可变性，String类型是不可变

2：线程安全：String中的对象不可变，可理解为常量，线程安全，StringBuffer有对方法或调用的方法执行同步锁，线程安全，StringBuilder没有对方法执行同步锁，线程不安全

3：性能：StringBuilder的性能比StringBuffer的性能好上10%-15%

操作少量的数据：用String

单线程下StringBuilder

多线程下用StringBuffer



## String为什么是不可变的？

两个原因：

1：保存字符串的数组被final修饰且为私有的，没有提供让外界修改这个字符串的方法

2：String类被final修饰，不能被子类继承，避免了子类破坏String不可变



## 字符串拼接用“+” 还是StringBuilder?

首先，+号实际上也是用StringBuilder的append方法再toString()成字符串，在JDK9以前，+号做字符串拼接容易创建多个StringBuilder对象，在JDK9后，有一个动态方法，让+号只创建一个StringBuilder对象



## String的equals() 和 Object的equals()有何区别？

Object的equals（）比较的是两个对象的内存地址是否相等，等价于==，String的equals（）重写了Object的equals（），作用是比较两个字符串的值是否相等



## 字符串常量池的作用了解吗？

JVM特意开辟出来的节约内存，提高性能的一片区域，主要目的是为了避免字符串的重复创建



## String s1=new String("abc"),这句话创建了几个字符串对象？

可能创建一个或两个字符串对象

如果字符串常量池里面没找到这个对象的引用，会创建两个堆对象，其中一个作为字符串常量的引用

如果有找到，就只会创建一个堆对象



String s2="abc"

它会先从字符串常量池去找这个对象的引用，如果没有才会创建一个对象，如果有直接返回那个引用



## String的intern方法有什么用？

它是本地方法，作用是把字符串的引用保存到字符串常量池

分两种情况

1.字符串常量池已经有这个对象的引用的话，它会直接返回引用

2.字符串常量池没有这个对象引用，会创建一个字符串的引用，然后再返回



## String类型的变量和常量做“+”运算时发生了什么？

在JavaC编译器中，有一个操作叫常量折叠，会影响到编译

final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true