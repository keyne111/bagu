# Redis（上）

## 什么是redis?

redis是一款基于C语言的开源NOSQL数据库，它被广泛应用在分布式缓存方向,它的数据都是存在内存中的，所以读写速度非常快，并且数据都是以key，value去存储的。

然后redis还面对多种业务场景有实现方案，比如内置多种数据结构，支持事务，持久化，lua脚本，提供多种开箱即用的集群方案



## redis为什么这么快？

基于内存，内存的读写效率比磁盘高

基于reactor模式设计开发了一套事件处理方案，主要是单线程事件循环和IO多路复用

优化数据结构/类型，性能非常高

通信协议简单且解析高效



## 除了redis，你还知道哪些分布式缓存方案？

Dragonfly:能够兼容redis和memcached的API，号称世界上最快的内存数据库

KeyDB:redis的高性能分支，专注于多线程，内存效率，高吞吐量



## 说一下redis和Memcached的相同点和区别？

相同点：

都是基于内存的，都被当做缓存使用

都有相同的过期策略

两者的性能都非常高

区别：
redis有丰富的数据类型，除了最简单的k/v型，还有list,set,zet,hash等数据结构。而memcached只有k/v型数据

redis可以把内存中的数据写入到磁盘，支持数据持久化，而memcached不行

redis原生支持集群模式，而memcached不行，它只能依靠客户端向集群中分片写入数据



## 为什么要用redis?

访问速度快，因为redis是基于内存的，而传统数据库像MySQL是基于磁盘的，如果用redis访问高频的数据的话，性能可以提升几十倍甚至上百倍。

高并发：传统的MySQL的qps是4k左右，而用了redis之后可以达到5w+,甚至10w+.如果我们把一些数据库的数据迁移到redis的话，可以提高系统的整体并发量。

功能全面：redis除了被用作缓存外，还支持多重业务场景，比如分布式锁，限流，消息队列，延时队列等等



## 3种常见的缓存读写策略了解吗？

1：旁路缓存模式：适用于读请求比较多的场景，也是我们比较常用的

写：先更新数据库，后删除缓存

读：先从缓存中看看有没有，有的话直接返回

​		没有的话去数据库查找，返回，然后把查找到的数据写入缓存

写操作可以先删除缓存，再更新数据库吗？

不行，因为这样容易造成数据不一致性。如果请求1先删除缓存，请求2去读数据库，这时读的是未更新的数据，请求1再去更新数据库。这时数据不一致了。

那更新数据库再删除缓存就不会造成数据不一致了吗？
还是有可能造成数据不一致，但是概率很小，因为缓存的写入速度比数据库的写入速度快，间隔时间很小，不过如果发生请求1先读数据库A数据，请求2更新数据库A数据（并且这时缓存中没有A数据），请求1把A数据写入缓存。这样也是会造成数据不一致。

缺陷：首次访问缓存都会找不到数据。

解决：提前把热点数据放进缓存中。

**缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。**

解决办法：

- 数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。
- 可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。

2：读写穿透

写：先查cache，cache中不存在，直接更新db

​	cache中存在，则先更新cache，然后cache服务自己更新db

读：如果cache中有，则返回cache

​		如果换成中没有，则从数据库中查找，加载到cache，在返回cache中的数据



3：异步缓存写入



## 什么是redis module?有什么用？

redis从4.0开始，支持module扩展功能满足特殊的需求，这些module以动态链接库的形式被加载到redis，这是一种非常灵活的动态扩展功能的方式。

我们可以自定义module实现搜索引擎，分布式锁，分布式限流等。



## redis除了做缓存，还可以做什么？

分布式锁：redis可以用redisson做分布式锁

限流：一般是redis+lua脚本，或者通过redisson也可以做限流，底层是lua代码和令牌桶算法

延时队列：redisson中内置了延时队列（基于Sorted Set实现）

分布式session：使用String或者Hash数据类型保存session数据，所有服务器都可以访问



## redis可以做消息队列吗？

可以做，但是相比较于专业的消息队列，像rabbitmq，Kafka，它存在很多不足，比如容易造成消息丢失和堆积问题不好解决。



## 如何基于redis实现延时任务？

类似的问题：

- 订单在 10 分钟后未支付就失效，如何用 Redis 实现？
- 红包 24 小时未被查收自动退还，如何用 Redis 实现？

两种方案，1：redis过期事件监听，不过这种方案监听的存在时效性差，易丢失消息，消息可能重复消费，所以不推荐

​					2：redisson内置的延时队列，它消息丢失的可能性小：因为delayed queue存消息是持久化的，即使redis宕机了，也最多丢失一点消息，影响不大，而且也可以通过扫描数据库再把消息补全

​					它不存在重复消费的可能：因为每个客户端都是从同一个消息队列获取任务的。



## redis中常用的数据类型有哪些？

5种常用的：String,list,set,zset,Hash

3种特殊的：HyperLogLog,BitMap,Geospatial

Bloom filter(布隆过滤器) ,Bitfield（位域）



## String的应用场景有哪些？

String是redis中最简单也是最常用的数据类型，它可以存储任何类型的数据比如整数，浮点数，字符串，图片，序列化后的对象等

它的常见应用场景有

存储常规数据的缓存，比如session，token等

计数，比如用户单位时间内的请求数，页面单位时间内的访问数

分布式锁（setnx key value命令可以实现一个最简单的分布式锁）



## 使用String还是Hash存储对象数据更好呢？

因为String存储的是序列化后的对象数据，存储的是整个对象，操作简单，

而Hash存储的是对象数据的字段，可以获取部分字段，也可以修改或添加对象的部分字段。

所以在大多数情况下，使用String存储对象数据会更好，尤其是对象结构简单并且整体读写操作的时候

如果需要频繁的操作对象的字段或节省内存的话，使用hash存储对象则是一个更好的选择



String的底层实现是什么？

作者自己编写了简单动态字符串（SDS）实现，它相比较于C语言中的字符串：

有避免缓冲区溢出，减少内存分配次数，二进制安全等优势



## 购物车信息用String还是Hash存储更好呢？

因为购物车信息容易频繁地修改，所以用hash存储更好

把用户id当成key,商品id当成field，商品数量当成value

这样的话，当需要增加商品，则增加hash中的field和value即可

​						删除商品，则删除field即可

​						修改商品，则修改对应field里面的value

​						查询商品，则遍历map

​						清空购物车的话，则删除用户id



## redis怎么实现排行榜功能？

redis中有一个Sorted Set的数据类型可以实现排行榜功能，比如说朋友圈的微信步数排行榜，直播的刷礼物的排行榜阿

然后相关的一些命令有‘zrange(从小到大排名)

zrevrange(从大到小排名)

zrevrank(按指定元素排名)



## Redis中Set集合的应用场景？

redis中的set集合是一种无序集合，它类似于Java中的HashSet

它有三种常见的应用场景：

1：存放的元素不能重复：比如文章点赞功能，动态点赞功能等

2：数据源之间有交集，并集，差集的场景：比如共同好友是交集，音乐推荐是差集，订阅号推荐是并集加差集

3：需要随机获取数据源中的元素的场景：比如抽奖系统，随机点名等



## 怎么用set实现一个简易的抽奖系统？

主要有三个命令

第一个是SADD KEY number1 number2...  向指定集合中添加一个或多个元素

第二个是SPOP KEY COUNT                           随机移除并获取指定集合中的一个或多个元素，适合不允许重复中奖的场景

第三个是Srandmember key count               随机获取指定集合中指定数量的元素，允许重复中奖的场景



## redis给缓存数据设置过期时间有什么用？（redis为什么要给数据设置过期时间？）

这个主要是因为redis中的数据都是存在内存中的，而内存有限并且珍贵，如果缓存数据不设置过期时间，那它就会一直增加，有可能出现那个内存不足，OOM的问题，然后除了字符串之外，我们可以用expire命令添加过期时间，字符串的话要用setex去添加过期时间，persist可以  移除一个键的过期时间

然后我们在一些业务场景其实也需要用过期时间来实现，比如短信服务的验证码只在一分钟内有效，登录token只在一天内有效。

这些数据使用过期时间来缓存的话比较方便



## redis怎么判断key是否过期？

redis中有一个过期字典来保存数据的过期时间，它的key存的是redis中数据的key，value则存的是一个long long类型的数据，表示的是key对应的过期时间。

然后redis查找某个key的时候，会先看一下key是否在过期字典中，如果不在则直接返回，如果在的话，需要先看一下key是否过期，过期的话要删除（redis中的key）然后返回null



## 常见的过期数据的删除策略了解吗？

1：惰性删除：只会在取出/查询key的时候对key进行过期检查。这种方式对CPU最友好，不过可能造成大量的过期数据没有被删除

2：定期删除：设置周期，在周期内随机挑选一批设置了过期时间的key,然后逐个查看是否过期，这种方式相比较于惰性删除，对内存友好，但是对CPU不友好

3：延迟队列：把设置了过期时间的key放到延迟队列，过期就删除key，这种方式可以保证过期的key一定会被删除，不过需要维护延迟队列，延迟队列自己也占用资源

4：定时删除：为每一个过期时间的key设置定时器，这种方式可以确保key过期后一定会被删除，不过因为设置了定时器，所以它对CPU的压力是最大的



## redis采用的是哪种过期数据删除策略？

redis采用的是定期删除+惰性/懒汉式删除结合的策略，这也是大多数缓存框架采用的策略，因为定期删除对内存友好，而惰性删除对CPU友好，两者兼顾起来就能起到既对内存友好又对CPU友好的情况。



## redis中的定期删除具体流程了解吗？

首先，因为定期删除是设定了一个周期，然后在周期内随机挑选一批设置了过期时间的key,逐个进行扫描删除，因此有可能出现过期key没有被删除的情况。

然后这个删除过程中有一些特殊情况

比如，如果执行时间超过阈值，则会中断这一次的定期删除循环，避免过多使用CPU时间

​			如果这一批删除的key超过了一定比例的话，则会重复执行这次删除流程，更积极地删除过期key,

​			如果这一批删除的key小于比例的话，则会中断定期删除循环，避免做更多的工作得到很少的内存回收



定期删除的随机抽查次数是多少？

这取决于版本，像redis7.2中，这个抽查数字是20



如何控制定期删除过期key的执行频率？

可以通过hz参数，这个参数的默认值是10，代表每秒执行10次定期删除，然后hz的范围在1-500之间，提高hz会让CPU的使用率提高。

然后除了定期删除过期key之外其它的一些定期任务，比如关闭超时客户端连接，也可以通过hz参数配置



为什么定期删除策略不是把所有的过期key都删除？

这主要是为了平衡内存和性能考虑的，因为如果要删除所有key的话，数量少还没关系，如果数量很多，每一次扫描都会消耗大量的性能，没有什么必要



## 为什么redis的key过期之后不是直接删除，这样不是会造成浪费内存空间吗？

主要是因为key过期之后立刻删除成本很大，比如删除策略中有两种方式都可以达到这一点，第一种方式是延迟队列，把设置了过期时间的key都放到延时队列上面，但是维护延时队列成本很高，因为可能key太多存放不下，需要多个，然后修改key修改过期时间的话也得调整它在延时队列的位置，

第二种方式是定时删除，它是为每一个过期key设置定时器，这样对CPU压力很大



大量key集中过期怎么办？

首先，大量key集中过期的话，可能会让redis的请求延迟变高。这时我们有两种方案

第一个方案是尽量避免key集中过期，我们可以把过期时间设置的随机一点

第二个方案是开启redis的lazyfree机制，可以在redis.conf文件里面去配置，开启之后会在后台异步删除过期key,不会阻塞主线程的运行



redis的内存淘汰策略了解吗？

redis的内存淘汰策略只有在运行内存达到了配置的阈值的时候才会生效，这个配置可以在redis.conf文件中的maxmemory参数去配置，然后64位操作系统的话，默认是0，表示不限制内存大小，32位操作系统的话，默认是3GB



redis有6种内存淘汰策略，默认使用的是no-eviction:禁止驱逐数据，当内存不足以容纳新数据的时候，新写入操作会报错



# Redis（下）

## 什么是redis事务？

它提供了一种将多个命令请求打包的功能。然后按顺序执行打包的命令。

优点是不会被中途打断。

缺点的话是不满足原子性和持久性，每一次事务命令都会与redis服务器交互，浪费内存资源



## redis的事务支持原子性吗？

不支持原子性，redis的事务跟MySQL的事务不一样，然后原子性的定义是事务的最小执行单位，不能分割，然后事务要么全执行，要么全不执行。

而redis的事务执行失败的情况下，除了执行过程中出现错误的命令，其它命令都能执行，不会出现出现回滚操作。

这主要是因为redis的开发者觉得这样更方便，有错误的话在开发过程中发现就可以了。



redis支持持久化吗？

redis有三种持久化方式，

快照（RDB）

只追加文件（AOF）

RDB和AOF的混合持久